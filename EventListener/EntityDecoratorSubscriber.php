<?php
declare(strict_types=1);

namespace Ordermind\LogicalAuthorizationDoctrineORMBundle\EventListener;

use Symfony\Component\EventDispatcher\EventSubscriberInterface;

use Doctrine\Common\Inflector\Inflector;

use Ordermind\LogicalAuthorizationDoctrineORMBundle\Event\EntityDecoratorEvents\BeforeMethodCallEventInterface;
use Ordermind\LogicalAuthorizationDoctrineORMBundle\Event\EntityDecoratorEvents\BeforeSaveEventInterface;
use Ordermind\LogicalAuthorizationDoctrineORMBundle\Event\EntityDecoratorEvents\BeforeDeleteEventInterface;

use Ordermind\LogicalAuthorizationBundle\Services\LogicalAuthorizationModelInterface;

/**
 * Event subscriber for entity decorator events
 */
class EntityDecoratorSubscriber implements EventSubscriberInterface
{
    /**
     * @var Ordermind\LogicalAuthorizationBundle\Services\LogicalAuthorizationModelInterface
     */
    protected $laModel;

    /**
     * @internal
     *
     * @param Ordermind\LogicalAuthorizationBundle\Services\LogicalAuthorizationModelInterface $laModel LogicalAuthorizationModel service for checking model permissions
     */
    public function __construct(LogicalAuthorizationModelInterface $laModel)
    {
        $this->laModel = $laModel;
    }

    /**
      * {@inheritdoc}
      */
    public static function getSubscribedEvents(): array
    {
        return [
        'logauth_doctrine_orm.event.entity_decorator.before_method_call' => [
        ['onBeforeMethodCall'],
        ],
        'logauth_doctrine_orm.event.entity_decorator.before_save' => [
        ['onBeforeSave'],
        ],
        'logauth_doctrine_orm.event.entity_decorator.before_delete' => [
        ['onBeforeDelete'],
        ],
        ];
    }

    /**
     * Event subscriber callback for aborting method call on entity if access is not granted
     *
     * @param Ordermind\LogicalAuthorizationDoctrineORMBundle\Event\EntityDecoratorEvents\BeforeMethodCallEventInterface $event The subscribed event
     */
    public function onBeforeMethodCall(BeforeMethodCallEventInterface $event)
    {
        static $storedMethods;
        if (!isset($storedMethods)) {
            $storedMethods = [];
        }

        $entity = $event->getEntity();
        $method = $event->getMethod();
        $arguments = $event->getArguments();
        $field = null;
        $action = null;

        // Support for __get() and __set()
        if ('__get' === $method) {
            $field = $arguments[0];
            $action = 'get';
        } elseif ('__set' === $method) {
            $field = $arguments[0];
            $action = 'set';
        }

        // Support for field-specific getters and setters generated by Doctrine
        if (!$action) {
            $class = get_class($entity);

            if (!isset($storedMethods[$class])) {
                $metadata = $event->getMetadata();
                $fieldNames = $metadata->getFieldNames();
                $storedMethods[$class] = [];
                foreach ($fieldNames as $fieldName) {
                    $storedMethods[$class][$fieldName] = $this->getFieldMethods($entity, $fieldName);
                }
            }

            foreach ($storedMethods[$class] as $fieldName => $methods) {
                if (in_array($method, $methods['getters'])) {
                    $field = $fieldName;
                    $action = 'get';
                    break;
                } elseif (in_array($method, $methods['setters'])) {
                    $field = $fieldName;
                    $action = 'set';
                    break;
                }
            }
        }

        // If the method is a known getter or setter, do a suitable permission check on the entity and then on the field.
        if ('get' === $action) {
            if (!$this->laModel->checkModelAccess($entity, 'read')) {
                $event->setAbort(true);
            }
            if (!$event->getAbort() && !$this->laModel->checkFieldAccess($entity, $field, 'get')) {
                $event->setAbort(true);
            }
        } elseif ('set' === $action) {
            if ($event->isNew()) {
                if (!$this->laModel->checkModelAccess($entity, 'create')) {
                    $event->setAbort(true);
                }
            } else {
                if (!$this->laModel->checkModelAccess($entity, 'update')) {
                    $event->setAbort(true);
                }
            }
            if (!$event->getAbort() && !$this->laModel->checkFieldAccess($entity, $field, 'set')) {
                $event->setAbort(true);
            }
        }
    }

    /**
     * Event subscriber callback for aborting saving of entity if access is not granted
     *
     * @param Ordermind\LogicalAuthorizationDoctrineORMBundle\Event\EntityDecoratorEvents\BeforeSaveEventInterface $event The subscribed event
     */
    public function onBeforeSave(BeforeSaveEventInterface $event)
    {
        $entity = $event->getEntity();
        if ($event->isNew()) {
            if (!$this->laModel->checkModelAccess($entity, 'create')) {
                $event->setAbort(true);
            }
        } else {
            if (!$this->laModel->checkModelAccess($entity, 'update')) {
                $event->setAbort(true);
            }
        }
    }

    /**
     * Event subscriber callback for aborting deletion of entity if access is not granted
     *
     * @param Ordermind\LogicalAuthorizationDoctrineORMBundle\Event\EntityDecoratorEvents\BeforeDeleteEventInterface $event The subscribed event
     */
    public function onBeforeDelete(BeforeDeleteEventInterface $event)
    {
        $entity = $event->getEntity();
        if (!$event->isNew() && !$this->laModel->checkModelAccess($entity, 'delete')) {
            $event->setAbort(true);
        }
    }

    /**
     * @internal
     *
     * @param object $entity
     * @param string $fieldName
     *
     * @return array
     */
    protected function getFieldMethods($entity, string $fieldName): array
    {
        $camelizedFieldName = Inflector::classify($fieldName);

        $methods = [
        'getters' => [
        "get$camelizedFieldName",
        "is$camelizedFieldName",
        ],
        'setters' => [
        "set$camelizedFieldName",
        ],
        ];

        foreach ($methods as $action => $actionMethods) {
            foreach ($actionMethods as $i => $method) {
                if (!method_exists($entity, $method)) {
                    unset($methods[$action][$i]);
                }
            }
        }

        return $methods;
    }
}
