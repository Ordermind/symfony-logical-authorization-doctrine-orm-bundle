<?php

namespace Ordermind\LogicalAuthorizationDoctrineORMBundle\EventListener;

use Symfony\Component\EventDispatcher\EventSubscriberInterface;

use Doctrine\Common\Inflector\Inflector;

use Ordermind\LogicalAuthorizationDoctrineORMBundle\Event\EntityDecoratorEvents\BeforeMethodCallEventInterface;
use Ordermind\LogicalAuthorizationDoctrineORMBundle\Event\EntityDecoratorEvents\BeforeSaveEventInterface;
use Ordermind\LogicalAuthorizationDoctrineORMBundle\Event\EntityDecoratorEvents\BeforeDeleteEventInterface;

use Ordermind\LogicalAuthorizationBundle\Services\LogicalAuthorizationModelInterface;

class EntityDecoratorSubscriber implements EventSubscriberInterface {
  protected $laModel;

  /**
   * @internal
   *
   * @param Ordermind\LogicalAuthorizationBundle\Services\LogicalAuthorizationModelInterface $laModel LogicalAuthorizationModel service for checking model permissions
   */
  public function __construct(LogicalAuthorizationModelInterface $laModel) {
    $this->laModel = $laModel;
  }

  /**
    * {@inheritdoc}
    */
  public static function getSubscribedEvents() {
    return array(
      'logauth_doctrine_orm.event.entity_decorator.before_method_call' => array(
        array('onBeforeMethodCall'),
      ),
      'logauth_doctrine_orm.event.entity_decorator.before_save' => array(
        array('onBeforeSave'),
      ),
      'logauth_doctrine_orm.event.entity_decorator.before_delete' => array(
        array('onBeforeDelete'),
      ),
    );
  }

  /**
   * Event subscriber callback for aborting method call on entity if access is not granted
   *
   * @param Ordermind\LogicalAuthorizationDoctrineORMBundle\Event\EntityDecoratorEvents\BeforeMethodCallEventInterface $event The subscribed event
   */
  public function onBeforeMethodCall(BeforeMethodCallEventInterface $event) {
    static $stored_methods;
    if(!isset($stored_methods)) $stored_methods = array();

    $entity = $event->getEntity();
    $method = $event->getMethod();
    $arguments = $event->getArguments();
    $field = null;
    $action = null;

    // Support for __get() and __set()
    if($method === '__get') {
      $field = $arguments[0];
      $action = 'get';
    }
    elseif($method === '__set') {
      $field = $arguments[0];
      $action = 'set';
    }

    // Support for field-specific getters and setters generated by Doctrine
    if(!$action) {
      $class = get_class($entity);

      if(!isset($stored_methods[$class])) {
        $metadata = $event->getMetadata();
        $field_names = $metadata->getFieldNames();
        $stored_methods[$class] = array();
        foreach($field_names as $field_name) {
          $stored_methods[$class][$field_name] = $this->getFieldMethods($entity, $field_name);
        }
      }

      foreach($stored_methods[$class] as $field_name => $methods) {
        if(in_array($method, $methods['getters'])) {
          $field = $field_name;
          $action = 'get';
          break;
        }
        elseif(in_array($method, $methods['setters'])) {
          $field = $field_name;
          $action = 'set';
          break;
        }
      }
    }

    // If the method is a known getter or setter, do a suitable permission check on the entity and then on the field.
    if($action === 'get') {
      if(!$this->laModel->checkModelAccess($entity, 'read')) {
        $event->setAbort(true);
      }
      if(!$event->getAbort() && !$this->laModel->checkFieldAccess($entity, $field, 'get')) {
        $event->setAbort(true);
      }
    }
    elseif($action === 'set') {
      if($event->isNew()) {
        if(!$this->laModel->checkModelAccess($entity, 'create')) {
          $event->setAbort(true);
        }
      }
      else {
        if(!$this->laModel->checkModelAccess($entity, 'update')) {
          $event->setAbort(true);
        }
      }
      if(!$event->getAbort() && !$this->laModel->checkFieldAccess($entity, $field, 'set')) {
        $event->setAbort(true);
      }
    }
  }

  /**
   * Event subscriber callback for aborting saving of entity if access is not granted
   *
   * @param Ordermind\LogicalAuthorizationDoctrineORMBundle\Event\EntityDecoratorEvents\BeforeSaveEventInterface $event The subscribed event
   */
  public function onBeforeSave(BeforeSaveEventInterface $event) {
    $entity = $event->getEntity();
    if($event->isNew()) {
      if(!$this->laModel->checkModelAccess($entity, 'create')) {
        $event->setAbort(true);
      }
    }
    else {
      if(!$this->laModel->checkModelAccess($entity, 'update')) {
        $event->setAbort(true);
      }
    }
  }

  /**
   * Event subscriber callback for aborting deletion of entity if access is not granted
   *
   * @param Ordermind\LogicalAuthorizationDoctrineORMBundle\Event\EntityDecoratorEvents\BeforeDeleteEventInterface $event The subscribed event
   */
  public function onBeforeDelete(BeforeDeleteEventInterface $event) {
    $entity = $event->getEntity();
    if(!$event->isNew() && !$this->laModel->checkModelAccess($entity, 'delete')) {
      $event->setAbort(true);
    }
  }

  protected function getFieldMethods($entity, $field_name) {
    $camelizedFieldName = Inflector::classify($field_name);

    $methods = array(
      'getters' => array(
        "get$camelizedFieldName",
        "is$camelizedFieldName",
      ),
      'setters' => array(
        "set$camelizedFieldName",
      ),
    );

    foreach ($methods as $action => $action_methods) {
      foreach($action_methods as $i => $method) {
        if (!method_exists($entity, $method)) {
          unset($methods[$action][$i]);
        }
      }
    }

    return $methods;
  }
}
